import 'package:analyzer/dart/element/element.dart';
import 'package:analyzer/dart/element/visitor.dart';

export 'builder.dart';

class LibraryVisitor extends RecursiveElementVisitor {
  List<ClassElement> classElements = [];

  @override
  void visitClassElement(ClassElement element) {
    if (!element.isPrivate) {
      classElements.add(element);
    }
    super.visitClassElement(element);
  }
}

class ReflectableSourceWrapper {
  final COLLECTION_IMPORT =
      '''import 'dart:collection' show HashSet, UnmodifiableListView;''';
  final MAPPER_IMPORT =
      '''import 'package:dart_json_mapper/dart_json_mapper.dart' show JsonMapper, JsonMapperAdapter, typeOf;''';
  final REFLECTABLE_INIT_METHOD = 'initializeReflectable';
  final REFLECTABLE_INIT_METHOD_PATCH = '_initializeReflectable';
  final INIT_METHOD =
      'JsonMapper initializeJsonMapper({List<JsonMapperAdapter> adapters = const []}) {';

  final LibraryVisitor _libraryVisitor = LibraryVisitor();

  LibraryElement inputLibrary;
  Map<String, dynamic> options;

  ReflectableSourceWrapper(this.inputLibrary, this.options) {
    inputLibrary.visitChildren(_libraryVisitor);
  }

  Iterable<String> get allowedIterables {
    return (options['iterables'] as String).split(',').map((x) => x.trim());
  }

  bool get isCollectionImportNeeded {
    return allowedIterables.contains('HashSet') ||
        allowedIterables.contains('UnmodifiableListView');
  }

  String get _libraryAdapterId {
    return '_$_libraryName';
  }

  String get _libraryName {
    return inputLibrary.identifier.split('/').last.replaceAll('.dart', '') +
        'Adapter';
  }

  String _renderValueDecoratorsForClassElement(ClassElement element) {
    return [
      ...[
        'List',
        'Set'
      ].where((x) => allowedIterables.contains(x)).map((iterable) =>
          '''    typeOf<$iterable<${element.name}>>(): (value) => value.cast<${element.name}>()'''),
      ...[
        'HashSet'
      ].where((x) => allowedIterables.contains(x)).map((iterable) =>
          '''    typeOf<$iterable<${element.name}>>(): (value) => $iterable<${element.name}>.of(value.cast<${element.name}>())'''),
      ...[
        'UnmodifiableListView'
      ].where((x) => allowedIterables.contains(x)).map((iterable) =>
          '''    typeOf<$iterable<${element.name}>>(): (value) => $iterable<${element.name}>(value.cast<${element.name}>())''')
    ].join(',\n');
  }

  String _renderValueDecorators() {
    return _libraryVisitor.classElements
        .map((e) => _renderValueDecoratorsForClassElement(e))
        .join(',\n');
  }

  String _renderLibraryAdapterDefinition() {
    return ''' 
final $_libraryAdapterId = JsonMapperAdapter(
  title: '$_libraryName',
  url: '${inputLibrary.identifier}',
  valueDecorators: {
${_renderValueDecorators()}
});\n''';
  }

  String _renderLibraryAdapterRegistration() {
    return '''
  $REFLECTABLE_INIT_METHOD_PATCH();
  [...adapters, $_libraryAdapterId].forEach((x) => JsonMapper().useAdapter(x));
  return JsonMapper();
}''';
  }

  String _autoCorrectImport(String import) {
    if (inputLibrary.identifier == import) {
      // local import
      final importParts = import.split('/');
      return importParts.last;
    }

    return import;
  }

  String _renderHeader() {
    return '''
// This file has been generated by the dart_json_mapper package.
// https://github.com/k-paxian/dart-json-mapper
''';
  }

  String _renderImports() {
    return {
          isCollectionImportNeeded ? COLLECTION_IMPORT : null,
          MAPPER_IMPORT,
          ..._libraryVisitor.classElements.map((e) =>
              '''import '${_autoCorrectImport(e.library.identifier)}';''')
        }.where((x) => x != null).join('\n') +
        '\n\n';
  }

  String _removeObjectCasts(String input) {
    return input.replaceAll('<Object>', '');
  }

  String _patchInitMethod(String input) {
    final PATCH = '\n' +
        _renderLibraryAdapterDefinition() +
        '\n' +
        INIT_METHOD +
        '\n' +
        _renderLibraryAdapterRegistration();
    return input.replaceFirst(
            REFLECTABLE_INIT_METHOD, REFLECTABLE_INIT_METHOD_PATCH) +
        PATCH;
  }

  String wrap(String reflectableGeneratedSource) {
    return _renderHeader() +
        _renderImports() +
        _patchInitMethod(_removeObjectCasts(reflectableGeneratedSource));
  }
}
